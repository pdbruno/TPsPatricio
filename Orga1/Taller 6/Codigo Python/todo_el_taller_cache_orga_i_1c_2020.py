# -*- coding: utf-8 -*-
"""Taller Cache Orga I 1C-2020

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NTqx3BnowHcVJwsPucOIFaSCA-SDmBta

# Uso del Colab Taller de Caché

## ¿Qué es un Colab?
Es un serevicio de máquina virtual ofrecido por Google. El código que escribimos y ejecutamos en un Colab se almacena y ejecuta en un servidor de Google.
- Lo bueno: Trabajamos desde el navegador sin instalar ningún programa previamente.
- Lo malo: Necesitamos conexión a internet (ver punto 2)

## Pasos para usar el Colab
1. Presionar el botón: 
"Open In Playgroung" o "Abrir en modo ensayo"
(esto es para comenzar a ejecutar los bloques de código)

2. Luego "Copiar en Drive"
(esto copia la máquina virtual en tu google drive, por lo que es una opción alternativa solo para aquellos que tienen cuenta de gmail. La ventaja: poder guardar los cambios realizados: si se corta internet no se pierden los avances)

3. Luego "Conectar"

## Pasos para usar el Colab Taller de Caché

1. Descargar los "Archivos necesarios"
2. Cargar las "Clases y funciones de políticas de desalojo" (politicas.py)
3. Cargar las "Clases y funciones del simulador de caché" (cache.py)
"""



"""Ejemplo simple de uso:"""

print ('Hola Mundo')

"""### Archivos necesarios"""

!wget https://gitlab.com/sebabedin/orga1/raw/master/benchmark.list  -O benchmark.list 
!wget https://gitlab.com/sebabedin/orga1/raw/master/benchmark_matrix_iguales.list -O benchmark_matrix_iguales.list
!wget https://gitlab.com/sebabedin/orga1/raw/master/benchmark_matrix_mix.list -O benchmark_matrix_mix.list

"""### Clases y funciones de políticas de desalojo

Hay cuatro políticas declaradas. La última la van a tener que definir ustedes. Es lo único de código Python que van a tener que escribir.
"""

import random

# Ejemplo de implementacion de FIFO
def FIFO(ways, addr_tag, addr_set):
	# Me fijo si alguna de las vias esta vacia, en ese caso devuelvo cual
	way_i=0
	for way in ways:
		if way[addr_set]['valid']==False: 
			return way_i
		way_i+=1
	
	# Si estoy aca es que ninguna esta vacia, tengo que desalojar alguna
	# segun la politica FIFO, es decir tengo que sacar aquella que haya
	# sido ingresada primero, para eso tengo que devolver la que
	# tenga el stepFirstUse mas viejo (numericamente menor)
	menor_step = ways[0][addr_set]['stepFirstUse']
	way_menor_step=0
	i=0
	for way in ways:
		if way[addr_set]['stepFirstUse'] < menor_step:
			# Encontre el minimo, actualizo
			menor_step=way[addr_set]['stepFirstUse']
			way_menor_step=i
		i+=1
	return way_menor_step
	
# Esta es gratis...
def RANDOM(ways, addr_tag, addr_set):
	# Busco si hay alguna vacia y devuelvo esa si corresponde
	try: return [ way[addr_set]['tag'] for way in ways].index(None)
	except:
		# Estan todas ocupadas, devuelvo cualquiera
		return random.randint(0,len(ways) - 1)
	

# Implementame por favor!
def LRU(ways, addr_tag, addr_set):
	# Me fijo si alguna de las vias esta vacia, en ese caso devuelvo cual
	way_i=0
	for way in ways:
		if way[addr_set]['valid']==False: 
			return way_i
		way_i+=1
	
	# Si estoy aca es que ninguna esta vacia, tengo que desalojar alguna
	# segun la politica LRU, es decir tengo que sacar aquella que fue utilizada 
	# hace más tiempo, para eso tengo que devolver la que
	# tenga el stepChange mas viejo (numericamente menor)
	menor_step = ways[0][addr_set]['stepChange']
	way_menor_step=0
	i=0
	for way in ways:
		if way[addr_set]['stepChange'] < menor_step:
			# Encontre el minimo, actualizo
			menor_step=way[addr_set]['stepChange']
			way_menor_step=i
		i+=1
	return way_menor_step
	
# Implementame por favor! (si queres...)
def MRU(ways, addr_tag, addr_set):
	while True:
		print ('Implementame che (si tenes ganas...) !!!! (soy LRU)')
		time.sleep(2)

"""### Clases y funciones del simulador de caché.

No es necesario entender este código. Sólo hay que correrlo.
"""

from math import log , ceil
#~ import repinf
import random
import numpy as np
import pylab
from collections import defaultdict

# from politicas import *
	
class CacheAsociativa_NWays(object):
	
	def __init__(self, memory=range(2**4), cacheSize=8, nWays=2,  nSets=2, cacheAlg=FIFO):
		# memory: array de enteros
		# cacheSize: Tamano de la cache en bytes
		# nWays: cantidad de Ways
		# nSets: cantidad de sets
		# cacheAlg: algoritmo de desalojo
		
		self.memory  = memory
		self.memorySize= len(self.memory)
		self.nWays = nWays
		self.cacheSize= cacheSize
		self.nSets = nSets
		self.cacheAlg = cacheAlg	
		self.sizeSet= self.cacheSize / (self.nWays * self.nSets)
		# stepChange va a guardar en que paso la accedi por ultima vez
		# stepFirstUse va a guardar el step en que lo cree
		self.ways = [ [{'valid':False,'tag': None,'stepChange':-1 ,'stepFirstUse':-1} for ii in range(int(self.nSets))] for i in range(int(self.nWays))]
		self.log = []
		self.step=-1
		
		
		# Calculo cantidad de bits para cada campo
		self.nbits_tag = int(ceil(log(ceil(float(self.memorySize) / (self.sizeSet*self.nSets)),2)))
		self.nbits_set = int(ceil(log(self.nSets,2)))
		self.nbits_index= int(ceil(log(self.sizeSet,2)))
		self.nbits_total= self.nbits_index + self.nbits_set  + self.nbits_tag
	
	def _nextStep(self):
		self.step+=1
		return self.step
	
	def getFields(self, address):
		f = self._getFields(address)
		return 'tag: ' + str(f['tag']) + ' set: ' + str(f['set']) + ' index: ' + str(f['index'])
		
	def _getFields(self,address):
		# dada una direccion obtengo a que tag, set e indice corresponde
		assert(self.memorySize > address) #, "address out of range:" + address + ". Memory size:" + self.memorySize
		adress_base2 = ("".join(["0" for i in range(self.nbits_total)])+str(bin(address)[2:]))[-self.nbits_total:]
		
		d_tag= int(adress_base2[:self.nbits_tag],2)
		try: d_set= int(adress_base2[self.nbits_tag:self.nbits_tag+self.nbits_set],2)
		except: d_set=0 # TODO: chequear q este bien esto
		d_index= int(adress_base2[self.nbits_tag+self.nbits_set:],2)
		return {'tag':d_tag,'set':d_set,'index':d_index}
	
	def _fields2Memory(self,tag,set,index):
		binary=("".join(["0" for i in range(self.nbits_total)])+"{0:b}".format(tag))[-self.nbits_tag:]
		binary+=("".join(["0" for i in range(self.nbits_total)])+"{0:b}".format(set))[-self.nbits_set:]
		binary+=("".join(["0" for i in range(self.nbits_total)])+"{0:b}".format(index))[-self.nbits_index:]
		return int(binary,2)
		
	def get_to_plot(self,way=0,set=0):
		t= dict(self.ways[way][set])
		return t
	
	
	def fetch(self, address):
		values_per_field = self._getFields(address)
		newStep = self._nextStep()
		
		# Tengo que revisar si esta guardado en la cache, para eso recorro cada via
		for wi,way in enumerate(self.ways):
			d = way[  values_per_field['set'] ] # Dic con keys: stepChange y tag
			
			if d['tag']== values_per_field['tag']: # Hit!
				
				# Actualizo el tiempo en que fue usado
				self.ways[wi][values_per_field['set'] ]['stepChange']=newStep
				
				# Obtengo el dato de la linea de cache
				dato = self.ways[wi][values_per_field['set']]['mem'][values_per_field['index']]
				
				# Pongo el pedido en el log
				self.appenToLog(address, True, wi, newStep)
								
				return "0x%X" %(dato)
		
		# Si estoy aca es porque no esta en la cache lo que quiero, 
		# uso el algoritmo de desalojo para decidir que via uso
		way2Use= self.cacheAlg(self.ways, values_per_field['tag'], values_per_field['set'])
		self.ways[way2Use][values_per_field['set'] ]['stepFirstUse']=newStep
		self.ways[way2Use][values_per_field['set'] ]['stepChange']=newStep
		self.ways[way2Use][values_per_field['set'] ]['tag']=values_per_field['tag']
		self.ways[way2Use][values_per_field['set'] ]['address_req']=address
		self.ways[way2Use][values_per_field['set'] ]['address']=[ int(self.sizeSet*int(address/self.sizeSet))+i for i in range(int(self.sizeSet))]
		self.ways[way2Use][values_per_field['set'] ]['mem']=[self.memory[a] for a in self.ways[way2Use][values_per_field['set'] ]['address']]
		self.ways[way2Use][values_per_field['set'] ]['valid']=True
		self.appenToLog(address, False, way2Use, newStep)
		
		# Obtengo el dato de la linea de cache
		dato = self.ways[way2Use][values_per_field['set']]['mem'][values_per_field['index']]
				
		return "0x%X" %(dato)

	def fetchFrom(self, fileName):
		# read memory access list
		access_list = np.array(open(fileName).read().split("\n")) # parse file
		access_list = access_list[access_list != '']  # remove empty elems
		access_list = [int(addr, 16) for addr in access_list] # convert from str to hex
		
		# Hago un fetch de cada direccion de memoria definida en la lista
		for addr in access_list:
			self.fetch(addr)
	
	def appenToLog(self, address, hit, line, newStep):
		self.log.append( {'address':address, 'hit':hit, 'line':line, 'step':newStep})

	def getLineRange(self, nWay, nSet):
		return self.ways[nWay][nSet]['address']

	def info(self):
		# Funcion para printear la cache
		res =""
		res+='Cantidad bits para Tags: '+str(self.nbits_tag)+"\n"
		res+='Cantidad bits para Set: '+str(self.nbits_set)+"\n"
		res+='Cantidad bits para Indice: '+str(self.nbits_index)+"\n"
		res+='Cantidad ways: '+str(self.nWays)+"\n"
		res+='Tamano de cada sets: '+str(self.sizeSet)+"\n"
		res+='Cantidad sets: '+str(self.nSets)+"\n"
		res+='Algoritmo de sustitucion: '+str(self.cacheAlg.func_name)+"\n"
		res+="\n"
		print (res)

	def __str__(self):
		res ="> Step:"+str(self.step)+"\n"
		
		res+="  "
		for wi in range(self.nWays):
			res+="----------------------------------------"
		res += '\n'
			
		res += '|'
		for wi in range(self.nWays):
			res+='\t\tWay:'+str(wi)+"\t\t\t |"
		res+='\n'
		
		#~ res+='|(tag - stepFirstUse - stepChange)\n'
		for si in range(self.nSets):
			res += '|'
			for way in self.ways:
				if way[si]['tag']==None: res+='\t\tInvalido\t\t |'
				else: 
					res+="\t  Tag:"+str(way[si]['tag'])
					res+=" First:"+str(way[si]['stepFirstUse'])
					res+=" Change:"+str(way[si]['stepChange'])+"\t |"
			res+='\n'
			
		res+="  "
		for wi in range(self.nWays):
			res+="----------------------------------------"
		res += '\n'
		
		res+="Hit rate:"
		if self.step != -1:
			res+=str(self.hitRate())
		else:
			res+='-'
		
		return res				

	def hitRate(self):
		return (np.array([ dict['hit'] for dict in self.log ])==True).mean()

	def infoCache(self,way=0,set=0):
		t= dict(self.ways[way][set])
		print ("Dir. pedida","	",t['address_req'])
		print ("Valido","		",t['valid'])
		print ("Tag","		",t['tag'])
		print ("Step 1st use","	",t['stepFirstUse'])
		print ("Step change","	",t['stepChange'])
		print ("Linea (Dir. Memoria y contenido):")
		for i in range(len(t['address'])):
			print ("| 0x%X	" % (int(t['address'][i])),)
		print ("|")
		for i in range(len(t['mem'])):
			print ("| %d	" % (t['mem'][i]),)
		print ("|")


	def mostrarLog(self):
		for c in self.log:
			print ('|	Step: %d	|	%s	|	Linea: %d	|	Direccion: %d	|' % (c['step'],'Hit'if c['hit'] else 'Miss',c['line'],c['address']))
		
class CacheTotalmenteAsociativa(CacheAsociativa_NWays):
	
	def __init__(self,memory, cacheSize=8, nLines=2,cacheAlg=FIFO):
		super( CacheTotalmenteAsociativa, self).__init__(memory,cacheSize=cacheSize,nWays=nLines, nSets=1, cacheAlg=cacheAlg)
		
	def get_to_plot(self,line):
		return super(CacheTotalmenteAsociativa, self).get_to_plot(way=line,set=0)

	def getLineRange(self, line):
		return self.ways[line][0]['address']	

	def __str__(self):
		res ="  ----------------Step:"+str(self.step)
		res+="---------------\n"
		
		for way in self.ways:
			res+="|"
			if way[0]['tag']==None: res+='\t\tInvalido\t\t |'
			else: 
				res+="\t  Tag:"+str(way[0]['tag'])
				res+=" First:"+str(way[0]['stepFirstUse'])
				res+=" Change:"+str(way[0]['stepChange'])+"\t |"
			res+='\n'
		res+="  --------------------------------------\n"
		res+="Hit rate: "
		if self.step != -1:
			res+=str(self.hitRate())
		else:
			res+='-'
		return res

	def infoCache(self,line):
		print ('Linea %d:' %(line))
		return super(CacheTotalmenteAsociativa, self).infoCache(way=line,set=0)

class CacheCorrespondenciaDirecta(CacheAsociativa_NWays):
		
	def __init__(self,memory, cacheSize=8, nLines=2):
		super( CacheCorrespondenciaDirecta, self).__init__(memory,cacheSize=cacheSize, nWays=1, nSets=nLines, cacheAlg=FIFO)
		
	def get_to_plot(self,line):
		return super(CacheCorrespondenciaDirecta, self).get_to_plot(way=0,set=line)

	def appenToLog(self, address, hit, line, newStep):
		values_per_field = self._getFields(address)

		self.log.append( {'address':address, 'hit':hit, 'line':values_per_field['set'], 'step':newStep})

	def getLineRange(self, line):
		return self.ways[0][line]['address']

	def __str__(self):
		res ="  ----------------Step:"+str(self.step)
		res+="---------------\n"
		
		way = self.ways[0]
		for si in range(int(self.nSets)):
			res+="|"
			if way[si]['tag']==None: res+='\t\tInvalido\t\t |'
			else: 
				res+="\t  Tag:"+str(way[si]['tag'])
				res+=" First:"+str(way[si]['stepFirstUse'])
				res+=" Change:"+str(way[si]['stepChange'])+"\t |"
			res+='\n'
		res+="  --------------------------------------\n"
		res+="Hit rate: "
		if self.step != -1:
			res+=str(self.hitRate())
		else:
			res+='-'
		return res					

	def infoCache(self,line):
		print ('Linea', str(line) +':')
		return super(CacheCorrespondenciaDirecta, self).infoCache(way=0,set=line)

"""# Taller de Caché

# 2.El simulador

## 2.3. Ejemplo de uso
A continuación presentamos un ejemplo de uso de la cache.

![](https://gitlab.com/sebabedin/orga1/raw/master/img01.png)

##Cómo usar el simulador de cache?
```
# Esto es un comentario en python

# Creamos una memoria de solo 16 bytes
memory = [0,0xA,0,0,0,0,0xF,0,0,0,0x5,0,0,0,0,0]

# Creamos la memoria cache
ca = CacheTotalmenteAsociativa(memory=memory, cacheSize=8, nLines=2, cacheAlg=FIFO)

# Imprimo el estado actual de la cache
print ca

#Dale play!
```
"""

# Esto es un comentario en python
 
# Creamos una memoria de solo 16 bytes
memory = [0,0xA,0,0,0,0,0xF,0,0,0,0x5,0,0,0,0,0]
 
# Creamos la memoria cache
ca = CacheTotalmenteAsociativa(memory=memory, cacheSize=8, nLines=2, cacheAlg=FIFO)
 
# Imprimo el estado actual de la cache
print (ca)

"""Como nunca se accedió a memoria luego de creada la cache es que que se ve así al imprimirse

La cache almacena el valor del step, que se aumenta cada vez que se hace un fetch, de este modo, podemos tener registro de en qué paso de la ejecución se creó y usó la cache. Como todavı́a no se realizó un fetch, este valor por ahora es -1.
A continuación, hacemos un fetch de la dirección 0x1. El estado de la cache actual será entonces:

![](https://gitlab.com/sebabedin/orga1/raw/master/img02.png)



```
# Accedo a la direccion 0x1 y obtengo el dato correspondiente
ca.fetch(0x1)

# Veo como cambio la cache
print ca

# Me fijo el historial de accesos y veo que se produjo un miss
ca.mostrarLog()

# Y miro el contenido de la linea 0
ca.infoCache(line=0)

# Veo el nuevo miss
ca.mostrarLog()
```
"""

# Accedo a la direccion 0x1 y obtengo el dato correspondiente
ca.fetch(0x1)

# Veo como cambio la cache
print (ca)

# Me fijo el historial de accesos y veo que se produjo un miss
ca.fetch(0x1)
ca.mostrarLog()

# Y miro el contenido de la linea 0
ca.infoCache(line=0)

"""# 3.Ejercicios

## 3.1. Ejercicio 1 - Seguimiento de Caché

### 3.1.1. Caché de correspondencia directa

Considerar la máquina de ORGA1 (palabras y direccionamiento de 16 bits, memoria de 128 KB), y con una memoria caché de correspondencia directa de 128 B con lı́neas de 32 B.

Suponiendo que la caché comienza vacı́a, determinar para la siguiente lista de accesos si se produce un hit o un miss en la caché.

Se accede a las siguientes direcciones de memoria en este orden:
0x0009, 0x001D, 0x000A, 0x0101, 0x0113, 0x000A, 0x001E, 0x0102, 0x0114
"""

palabraBytes    = 2
memoriaBytes    = 128 * 1024
cacheBytes      = 128
lineaBytes      = 32
memoriaPalabras = memoriaBytes / palabraBytes
cachePalabras   = cacheBytes / palabraBytes
lineaPalabras   = lineaBytes / palabraBytes
lineas          = cachePalabras / lineaPalabras

memoria = [0 for i in range(int(memoriaPalabras*1024))]

direcciones = [0x0009, 0x001D, 0x000A, 0x0101, 0x0113, 0x000A, 0x001E, 0x0102, 0x0114]

print('memoriaPalabras: %d' % (memoriaPalabras))
print('cachePalabras: %d' % (cachePalabras))
print('lineaPalabras: %d' % (lineaPalabras))
print('lineas: %d' % (lineas))

c1 = CacheCorrespondenciaDirecta(memory=memoria, cacheSize=cachePalabras, nLines=lineas)

for direccion in direcciones:
  print('Accediendo a la dirección: 0x%04X' % (direccion))
  c1.fetch(direccion)
  print(c1.getFields(direccion))
  print (c1)
  print('\r\r')

"""### 3.1.2. Caché completamente asociativa

Utilizando el simulador y la misma lista de accesos a memoria que en el punto anterior, complete la siguiente tabla utilizando a una memoria caché completamente asociativa de 128B, lı́neas de 32 B y una polı́tica de desalojo FIFO.
"""

c2 = CacheTotalmenteAsociativa(memory=memoria, cacheSize=cachePalabras, nLines=lineas, cacheAlg=FIFO)

for direccion in direcciones:
  print('Accediendo a la dirección: 0x%04X' % (direccion))
  c2.fetch(direccion)
  print(c2.getFields(direccion))
  print  (c2)
  print('\r\r')

"""## 3.2. Ejercicio 2 - Polı́ticas de desalojo

En este ejercicio queremos evaluar el impacto de usar distintas polı́ticas de desalojo.

### 3.2.1. Implementación de LRU

El simulador permite configurar las memoria caché para que utilice diferentes polı́ticas de desalojo. Actualmente se encuentran implementadas las politicas FIFO y RANDOM. Puede verse su implementación en el archivo politicas.py

Para implementar una polı́tica se utilizan los siguientes atributos asociados a una lı́nea (o set/vı́a) de cache:

- valid: Es un flag que establece si la lı́nea es válida o no

- stepChange: Guarda en que step se accedió por última vez una lı́nea

- stepFirstUse: Guarda en que step se cargó en la cache esta lı́nea

- address req: Guarda la dirección que se pidió para llenar esta lı́nea

- mem: Guarda los valores de memoria que se almacenaron en esta lı́nea

Utilizando las polı́ticas ya existentes en el simulador, implemente una nueva polı́tica: Least-Recently-Used (LRU) que desaloje la lı́nea que fue utilizada hace más tiempo. Opcionalmente, implemente también la polı́tica MRU (Most-Recently-Used). Como ejemplo, pueden observar la implementación de la polı́tica FIFO en politicas.py.
"""

memory = [0,0xA,0,0,0,0,0xF,0,0,0,0x5,0,0,0,0,0]

direcciones = [0, 4, 0, 8, 0, 12]

cFIFO = CacheTotalmenteAsociativa(memory=memory, cacheSize=8, nLines=2, cacheAlg=FIFO)
for direccion in direcciones:
  print('Accediendo a la dirección: 0x%04X' % (direccion))
  cFIFO.fetch(direccion)
  print(cFIFO.getFields(direccion))
  print (cFIFO)
  print('\r\r')

cLRU  = CacheTotalmenteAsociativa(memory=memory, cacheSize=8, nLines=2, cacheAlg=LRU)
for direccion in direcciones:
  print('Accediendo a la dirección: 0x%04X' % (direccion))
  cLRU.fetch(direccion)
  print(cLRU.getFields(direccion))
  print (cLRU)
  print('\r\r')

"""### 3.2.2. Hit Rate

Para analizar el comportamiento de la cache utilizando las distintas politicas existentes, podemos medir el hit rate que se obtiene para una serie de accesos a memoria. Para ello, tomaremos los accesos producidos por dos variantes de un mismo algoritmo, que se encarga de recorrer una matriz cuadrada y realizar una cierta operación. A continuación, podemos ver el pseudo-código de cada caso:

```
< operaciones >
for i =1:64:
  for j =1:64:
    < operaciones con acceso a matriz (i , j ) >
    < mas operaciones con acceso a matriz (i , j ) >
    < otras operaciones >
```

```
< operaciones >
for i =1:64:
  for j =1:64:
    < operaciones con acceso a matriz (i , j ) >
    < operaciones con acceso a matriz (j , i ) >
    < otras operaciones >
```

Los accesos a memoria asociados a cada ejecución se encuentran en los archivos benchmark_matrix_iguales.list y benchmark_matrix_mix.list, respectivamente.

Para una configuración de memoria de 128KB y una caché totalmente asociativa configurada como en el ejercicio anterior, se pide:
- a) Medir el hit rate que se produce para ambos códigos, con las polı́ticas FIFO, RANDOM y LRU.
- b) Explique la diferencia de performance de la cache encontrada entre ambos códigos, independientemente de la polı́tica utilizada.
- c) Explique cuál es el beneficio que obtiene entre utilizar FIFO y LRU, tras analizar el hit rate en ambos casos.

Para evaluar el hit rate asociado a cada secuencia de accesos, tras inicializar la cache con la configuración correspondiente, utilizar la función f etchF rom, que toma como parametro el nombre de un archivo y ejecuta f etch para cada una de las direcciones definidas en el archivo y luego calcular el hit rate utilizando hitRate.



```
# Traigo de memoria todas las direcciones en el order definido 
# en el archivo elegido
caFIFO_iguales.fetchFrom('benchmark_matrix_iguales.list')

# Corroboro el hitRate de la cache
print(caFIFO_iguales.hitRate())
```
"""

# Escribir el código acá

"""## 3.3. Ejercicio 3 - Análisis de Cache

Si quisiéramos decidir qué cantidad de lı́neas ponerle a nuestra caché, podemos utilizar el simulador para verificar el comportamiento esperado de antemano. Por ejemplo, se pueden graficar los resultados del hit rate para una serie de accesos a memoria (representativos de un código tı́pico), mediante el siguiente código:
"""

import numpy as np
import pylab

# Correspondencia directa, vario el número de lineas de la cache
# guardo el hit rate para cada configuracion
# usando la secuencia de fetchs definida en benchmark.list
nroDeLineas = [1,2,4]
res = []
for l in nroDeLineas:
    ca = CacheCorrespondenciaDirecta(
        memory=range(0, 2**16),
        cacheSize=128,
        nLines=l)
    ca.fetchFrom('benchmark.list')
    res.append( ca.hitRate() )
    print ("Lineas:", l, "HitRate:", ca.hitRate())

# res tiene los distintos valores de hit rates para cada configuracion
# uso pylab para plotear
pylab.plot(nroDeLineas,res,'.-',lw=2,label='CacheCorrespondenciaDirecta - FIFO')
pylab.xticks(size=16)
pylab.yticks(size=16)
pylab.xlim([0,np.max(nroDeLineas)])
pylab.xlabel('Lineas',size=16)
pylab.ylabel('Hit Rate',size=16)
pylab.title('Cache Correspondencia Directa',size=16)
pylab.show()